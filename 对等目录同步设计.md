# 对等目录同步设计

## 方案设计

1. **对等视角**  
   每个 Obsidian vault 始终把“当前 vault 根目录”视为本端根目录，把其他配置的目录视为对端根目录：  
   - 正向同步负责「本端 → 对端」；  
   - 反向同步负责「对端 → 本端」。  
   两端都装插件、互相指向对方目录时，本质上就是两个平等的根目录。

2. **三阶段同步模型（与先正向/先反向解耦）**

   同步时对于每个目标目录，按以下阶段执行：

   1. **阶段 0：日志合并**  
      - 通过 `mergeLogsForTargets(sourceRoot, [targetRoot])` 合并双方的删除/修改/重命名日志，得到一条按时间排序的统一事件流（包含 `side: "source" | "target"`, `modifiedAt`, `deletedAt`, 以及重命名元数据）。

   2. **阶段 1：收集变化（只读决策）**  
      - 使用 `getLatestUnresolvedEventsFor(relPath)` 对每个路径计算本端/对端最近的未解决事件：  
        `sourceModified / sourceDeleted / targetModified / targetDeleted`。  
      - 结合当前文件系统的 mtime，生成一份只读的反向同步“计划表（plan）”，每条类似于：
        - `{ type: "copyTargetToSource", relPath, sourcePath, targetPath, targetMtimeMs }`
        - `{ type: "conflict", relPath, sourcePath, targetPath }`
      - 关键规则：
        - **双端都有未解决修改/删除** → 标记为冲突，不静默覆盖，由 Notice + diff 视图提示处理。  
        - **仅对端有最新修改（targetModified）** → 生成 `copyTargetToSource` 计划。  
        - **仅本端有最新修改（sourceModified）** → 不生成反向覆盖计划，留给正向同步负责 `push modify`。  
        - **本端已有删除/重命名(delete/rename) 事件时**，反向同步不会从目标恢复该路径（防止“删除/重命名被撤销”），删除的传播交由正向同步完成。

   3. **阶段 2：执行计划（有序落盘）**  
      - `traverseTargetAndSync` 中先递归扫描并构建 `actions: ReverseSyncAction[]`，然后统一按 `actions` 执行：  
        - 对所有 `copyTargetToSource`：先 `ensureDir(sourcePath) + copyFileWithMetadata(target → source)`，再追加一条 `side: "target", event: "modified"` 日志。  
        - 对所有 `conflict`：统一弹出 Notice 并打开 diff 视图，不做自动覆盖。  
      - 删除场景在 `handleDeletions` 中集中处理：仅在“对端删除时间晚于本端最后修改时间”且无本端更近的修改/重命名事件时，才执行 `pull delete`；否则视为冲突或保留本端。

3. **重命名与修改/删除统一纳入冲突判定**

   - 对于本端重命名，使用 `logLocalRename(app, fromRelPath, toRelPath)` 写入两条日志：
     - 旧路径：`event: "deleted", side: "source", deletedAt, rename: true, renameTo, renameId`  
     - 新路径：`event: "modified", side: "source", modifiedAt, rename: true, renameFrom, renameId`  
   - 在阶段 1 中，这两条记录被视为一组“重命名事件”，同时仍然参与 `sourceDeleted/sourceModified` 的时间线计算；  
   - 因此重命名、本地修改、对端删除/修改都通过同一个 `LatestEvents` 模型参与冲突判定，不再有“重命名单独特殊处理、modify/delete 另外判”的分裂逻辑。

## 为何采用三阶段模式（方案选型依据）

在实现过程中，曾经尝试过简单的「先正向再反向」或「先反向再正向」两种顺序，实践证明都会在某些边界场景下产生难以接受的副作用，典型案例如下：

1. **本端重命名导致新文件被误删的案例**
   - 场景：在本 vault 中将 `old.md` 重命名为 `new.md`，此时源目录只剩 `new.md`；随后在 30 秒定时同步到来时：
     - 若直接「先反向、后正向」：  
       - 反向同步看到“目标没有 `new.md`，源有 `new.md`”，又看不到明确的 rename 语义，很容易在删除阶段把 `new.md` 视为“目标缺失 → 需要删除源端”，造成“刚重命名的文件被删掉”的现象。
     - 若强制「先正向、后反向」：  
       - 本端重命名会先推到目标，但如果目标一侧也对该文件做过修改/删除，简单顺序调整仍然无法清晰地区分“谁是主”，容易在另一类场景下产生静默覆盖。
   - 结论：只调换执行顺序（先正向/先反向），而仍然在执行阶段“边看边改”，无法同时满足：
     - 保证本端最近的重命名/修改不会被对端删除/旧状态覆写；
     - 又能在对端确实更“新”的情况下拉回变更。

2. **三阶段的解决方式**
   - 通过在反向同步中引入「统一判定 → 再统一执行计划」：
     - 在执行任何 delete/copy 之前，**先**用 `getLatestUnresolvedEventsFor` 看该路径是否有最新的 `sourceModified/sourceDeleted` 事件；
     - 如果本端最近有修改/重命名而对端没有明确的删除事件，则在 `handleSingleDeletion` 中提前 `return`，完全跳过对本端文件的删除，将删除的传播交给后续的正向同步；
     - 对“目标存在、源端不存在”的情况，同样在执行拷贝前统一检查是否存在源侧删除事件，避免把已经删除/重命名过的旧路径从目标“恢复”回来。
   - 这套逻辑只有在拆成「日志合并 → 只读决策（生成 actions）→ 按 actions 执行」之后才容易保证正确性；如果继续在执行路径中临时根据 mtime 和日志做即时决策，一旦调整顺序，就会再次出现类似“重命名后文件被删/被恢复”的回归。

基于以上实践案例，最终确定采用三阶段模式作为对等目录同步的核心方案，以解决“重命名 + 删除 + 双端修改”这类复杂场景下的正确性问题。


## 日志同步

> 什么情况下会写入side: target呢?

> 简单回答


"side": "target" 只会在「当前这个 vault 插件，记录的是 目标目录 上发生的事件」时写入日志，主要有两种情况，全部发生在 reverse-sync.ts 里：

---

### 1. 目标目录的删除事件（target 删除 → 决定是否删 source）

函数：appendDeletionLogEntry

- 在反向同步里，当发现：

- 源目录里有某个文件/目录

- 但目标目录中 已经不存在 这个路径

- 插件会调用 appendDeletionLogEntry(logPath, entry) 写一行日志，entry 会被扩展为：


```
{

  targetRoot,   // 哪个目标根目录

  relPath,      // 相对路径

  deletedAt,    // 第一次发现目标已删的时间或 null（清理标记）

  side: "target",

  event: "deleted"

}
```


也就是说：这是“目标侧把它删了”的一条删除候选记录，后续通过和源文件的 mtime 比较，决定是否真的删除源文件。

---

### 2. 目标目录的修改/新增写回源目录（target → source）

函数：appendModificationLogEntry

- 在反向同步遍历目标目录 traverseTargetAndSync 时，遇到：

1. 目标新增文件（源没有这个文件） → 复制到源；

2. 或 目标文件比源文件新、并且没有冲突（只有目标侧有未处理变更） → 复制覆盖源。

- 每次完成这种 “target → source” 的写回后，会调用：


```
appendModificationLogEntry(getDeletionLogPath(sourceRoot), {

  targetRoot,

  relPath,

  modifiedAt: <目标文件 mtime 的 ISO 字符串>,

});

appendModificationLogEntry 会补充：

{

  targetRoot,

  relPath,

  modifiedAt,

  side: "target",

  event: "modified"

}
```


表示：这一次这个文件最后是由目标目录写回源目录的，后续在判断冲突（getLatestUnresolvedEventsFor）和日志 merge 时就能区分“源改过”还是“目标改过”。

---

### 总结一句话

- 本地 Obsidian 里用户直接操作（创建/修改/删除） → 调用 logLocalSourceChange → 日志里是 "side": "source"。

- 反向同步过程中，从目标目录回写到本地，或检测到目标删除 → 调用 appendModificationLogEntry / appendDeletionLogEntry → 日志里是 "side": "target"。

那么side: target应该是不参与冲突判断的吧？

不是的，side: "target" 是参与冲突判断的，而且是必须的。

### 冲突判断里是怎么用的

在 reverse-sync.ts 里：

- 先从当前日志中取出某个 relPath 的最新事件：


```
const latest = getLatestUnresolvedEventsFor(relPath);

const hasSourceChange =

  !!latest.sourceModified || !!latest.sourceDeleted;

const hasTargetChange =

  !!latest.targetModified || !!latest.targetDeleted;
```


这里的：

- sourceModified / sourceDeleted 来自 "side": "source" 的日志；

- targetModified / targetDeleted 来自 "side": "target" 的日志。

然后在反向同步对比 mtime 时：


```
if (tgtStat.mtimeMs > srcStat.mtimeMs + MTIME_EPS_MS) {

  // 目标文件比源文件新

  if (hasSourceChange && hasTargetChange) {

    // 双方都有未处理变更，视为冲突（弹 Notice + 打开 diff）

  } else {

    // 只有目标有变更 → 安全覆盖源，并写入 side:"target" 日志

  }

} else {

  // 源比目标新

  if (hasSourceChange && hasTargetChange) {

    // 一样视为冲突

  }

  // 否则保留现状，交给正向同步

}
```


所以：

- 冲突 = 同一个路径上同时存在未解决的 "side": "source" 事件 和 "side": "target" 事件。

- side: "target" 不是被忽略的，而是“告诉本 vault：对端也改过这个文件”，用来阻止静默覆盖。

因为正常情况，side: source的日志，会在新增或修改端写入的，所以被同步的一端，正常情况就不需要再次写入side: target日志了，所以side:target日志就不参与冲突判断了吧？

按当前实现，side: "target" 仍然参与冲突判断，而且在“一端是哑目标目录”的场景里是必须的；在“两端都是 Obsidian + 插件”的纯对等场景里，理论上可以只靠 side: "source" 做冲突，但现在代码还没这么拆。

### 为什么现在还需要 side: "target"？

看一个典型时间线（只在 A 这边装了插件，B 是普通目录）：

1. 初始：A 写文件 → logLocalSourceChange(appA, ..., "modified") 记一条 side: "source"。

2. 后来 B 被别的程序改了：

- 只有 mtime 变了，没有任何 side: "source" 日志（因为 B 上没有插件）。

- 反向同步时看到 “B 比 A 新、且 A 这边目前没有未处理的 source 改动” → 允许 B 覆盖 A，并写一条 side: "target" 的 modified 日志，表示“上一次写回是从目标来的”。

1. 再后来 A 又改了同一个文件：

- 再记一条 side: "source" 的 modified 日志。

- 这时日志中同时存在最新的 sourceModified + 最新的 targetModified，getLatestUnresolvedEventsFor 会返回两边都有变更，hasSourceChange && hasTargetChange === true，下次再看 B 是否也改动时，就会把它识别为冲突，而不是“只有一边变更”再去覆盖。

如果你把 side: "target" 完全排除在冲突判断之外，那么对“只有 A 有插件、B 是哑目录”的情况：

- B 改 → A 通过反向同步接受覆盖（这是对的），但不会记下“目标曾经改过”的事实；

- 之后 A 与 B 再各自修改一次时，A 在判断时只看到“自己这边有 side: source 改动”，目标侧在日志里是“空白”，就会被当成“单边变更”，从而可能再次静默覆盖。

### 对等插件场景下的简化空间

在“两个 Obsidian 都装插件、互为对等目录”的理想场景里：

- B 在自己的 vault 上改文件时，会自己写 side: "source" 日志；

- 通过 mergeLogsForTargets(rootA, [rootB])，A 也能看到这条 “来自 B 的 source 事件”；

- 理论上，冲突判断可以只看 side: "source"（来自任一 root 的），而把 side: "target" 仅当作“已通过反向同步写回的痕迹”，不参与冲突。

但目前实现里，为了同时兼容“对等目录 + 单向同步（目标是普通文件夹）”两种用法，getLatestUnresolvedEventsFor 仍然把 side: "target" 作为“目标侧也有未处理变更”的信号参与冲突判断。

如果你希望在“对等插件”模式下把逻辑进一步拆干净（例如：只用 side: "source" 决定冲突，side: "target" 只做审计），可以再开一个配置或模式开关，我们就可以按控制变量法单独重构这一块。


